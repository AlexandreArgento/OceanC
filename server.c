#include <stdio.h> 
#include <string.h> 
#include <errno.h> 
#include <stdlib.h> 
#include <sys/socket.h> 
#include <arpa/inet.h> 
#include <unistd.h> 
#include <netdb.h>
#include <signal.h>

int listener_d;

void error(char *msg) {
	fprintf(stderr, "%s: %s\n", msg, strerror(errno));
	exit(1); 
} //error

int catch_signal(int sig, void (*handler)(int)) {
	struct sigaction action; 
	action.sa_handler = handler; 
	sigemptyset(&action.sa_mask); 
	action.sa_flags = 0;
	return sigaction (sig, &action, NULL); 
} //catch_signal

void handle_shutdown(int sig) {
	//Closes the socket in case of use of Ctrl-C
	if (listener_d) 
		close(listener_d);
	fprintf(stderr, "Socket closed!\n");
	exit(0);
} //handle_shutdown

int open_listener_socket() {
	int listener_d = socket(AF_INET, SOCK_STREAM, 0); 
	if (listener_d == -1)
		error("Cannot open socket");
	return listener_d; //returns a listener socket descriptor
} //open_listener_socket

void bind_to_port(int socket, int port) {
	struct sockaddr_in name; //Contexte d'adressage
	name.sin_family = AF_INET;
	name.sin_port = (in_port_t)htons(port);
	name.sin_addr.s_addr = htonl(INADDR_ANY);
	int reuse = 1;
	if (setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char *)&reuse, sizeof(int)) == -1)
		error("Cannot set the reuse option on the socket"); 
	//The reuse option allows us to reboot the server immediately if shut down
	//The lack of it would make us wait for 30 seconds for the port to be cleaned and made free
	int c = bind (socket, (struct sockaddr *) &name, sizeof(name));
	if (c == -1)
		error("Cannot bind to socket"); 
} //bind_to_port

void listen_socket(int listener_d,int queue){
	if(listen(listener_d,queue)==-1)
		error("Cannot listen");
} //listen_socket

int accept_connection(int listener_d,struct sockaddr_storage client_addr,unsigned int address_size){
	int connect_d = accept(listener_d, (struct sockaddr *)&client_addr, &address_size);
		//Wait until a client contacts the server
		//Create a secondary socket descriptor to hold the conversation with the client
	if (connect_d == -1)
		error("Cannot open secondary socket");
	return connect_d;
} //wait_for_connection
	
int read_in(int socket, char *buf, int len) {
	char *s = buf;
	int slen = len;
	int c = recv(socket, s, slen, 0); 
	while ((c > 0) && (s[c-1] != '\n')) {
		s += c; slen -= c;
		c = recv(socket, s, slen, 0);
	}
	if (c < 0) 
		return c;
	else if (c == 0) 
		buf[0] = '\0';
	else 
		s[c-1]='\0';
	return len - slen; 
} //read_in

int say(int socket, char *s) { 
	//Send a string to a client
	int result = send(socket, s, strlen(s), 0); 
	if (result == -1)
		fprintf(stderr, "%s: %s\n", "Error talking to the client", strerror(errno)); 
	return result;
} //read_in


void function_matcher(char* command, int id){
	if (strstr(command,"modif_speed ")){
		int speed = (int) (buf+12) 
		//oceanRegistery[id]->speed = newSpeed
	} 
	else if (strstr(command,"modif_direction")){
		//char direction = (buf+15) (int)
		//oceanRegistery[id]->direction = newDirection
	}
	else if (strstr(command,"say")){
		int i=0;
		/*
		for (i;i<7;i++){
			if(say(oceanRegistery[id][indice socket_d],("%d says %s", id, la suite de la string) 
		}
		*/
	}
	else if (strstr(command,"visualize")){
		//visualizeOcean
	}
	
}

int main(int argc, char *argv[]) {
	//Runs the code handle_shutdown if Ctrl-C is used
	if (catch_signal(SIGINT, handle_shutdown) == -1) 
		error("Cannot set the interrupt handler");
	
	//Port we will be using
	int port = 6543;
	
	//Open 
	listener_d = open_listener_socket(); 
	
	//Bind
	bind_to_port(listener_d, port); 
	
	//Listen
	listen_socket(listener_d,8);
	
	//Variable definition: 
	//  client_addr ---- client address
	//  address_size --- size of the address
	//  buf ------------ buffer where the server will read messages from the clients
	struct sockaddr_storage client_addr;
	unsigned int address_size = sizeof(client_addr);
	puts("Waiting for connection...");
	char buf_cli[255];
	char buf_serv[255];
	
	//initialisation de l'océan via le fichier 
	//thread lecture console serveur
	//thread deplacement des bateaux
	
	//Now we should loop the wait and fork a process for every incoming client
	//
	while(1){
		int connect_d = accept_connection(listener_d,client_addr,address_size);
		//close_socket(port);
		
		if(!fork()) {
			//We are in the child process here
			close(listener_d); //The child will only need the connect_d socket generated by accept()
			if(say(connect_d,"\nWelcome in OceanC, a C-based ocean simulator\nThe options you can use are the following:\n\n1- Modify the variables of your boat (speed, direction) ------ Use one of the following\n\t------------------------------------------------------ 'modif_speed newSpeed'\n\t------------------------------------------------------ 'modif_dir newDirection'\n2- Display a message to other boats -------------------------- 'say yourMessage'\n3- Visualize the current ocean ------------------------------- 'visualize'\n\n") != -1)	
				{
				read_in(connect_d,buf_cli,sizeof(buf_cli));
				//while
				//Le serveur doit prendre en charge le bateau qui arrive
						//Ajouter à l'annuaire
						//Ajouter à la carte
				//switch buf
				//pthread_join avec la fonction qui va bien
						//Afficher la mer
						//Changer vitesse/cap
						//Envoyer un message
			}	//if(say(...
			close(connect_d);
			exit(0);
		} //if(!fork)
	} //while(1)
} //main()

//Mutex sur la carte?? annuaire??



